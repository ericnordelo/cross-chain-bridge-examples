{
  "language": "Solidity",
  "sources": {
    "contracts/senders/SenderArbitrumL1.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"../crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol\";\n\ncontract SenderArbitrumL1 is CrossChainEnabledArbitrumL1 {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address bridge_) CrossChainEnabledArbitrumL1(bridge_) {}\n\n    function sendCrossChainMessage(\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) external payable {\n        _sendCrossChainMessage(destination, data, crossChainTxParams);\n    }\n}\n"
    },
    "contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"./LibArbitrumL1.sol\";\n\n/**\n * @dev https://arbitrum.io/[Arbitrum] specialization or the\n * {CrossChainEnabled} abstraction the L1 side (mainnet).\n *\n * This version should only be deployed on L1 to process cross-chain messages\n * originating from L2, or to send cross-chain messages from L1 to L2. For\n * the other side, use {CrossChainEnabledArbitrumL2}.\n *\n * The bridge contract is provided and maintained by the arbitrum team. You can\n * find the address of this contract on the rinkeby testnet in\n * https://developer.offchainlabs.com/docs/useful_addresses[Arbitrum's developer documentation].\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabledArbitrumL1 is CrossChainEnabled {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _bridge;\n\n    event RetryableTicketCreated(uint256 indexed ticketId);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address bridge) {\n        _bridge = bridge;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        return LibArbitrumL1.isCrossChain(_bridge);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        return LibArbitrumL1.crossChainSender(_bridge);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_sendCrossChainMessage}\n     *\n     * NOTE: Emits a RetryableTicketCreated with the Id of the new L2 ticket.\n     */\n    function _sendCrossChainMessage(\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal virtual override {\n        uint256 ticketId = LibArbitrumL1.sendCrossChainMessage(\n            _bridge,\n            destination,\n            data,\n            crossChainTxParams\n        );\n\n        emit RetryableTicketCreated(ticketId);\n    }\n}\n"
    },
    "contracts/crosschain/CrossChainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/CrossChainEnabled.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./errors.sol\";\n\n/**\n * @dev Provides information for building cross-chain aware contracts. This\n * abstract contract provides accessors and modifiers to control the execution\n * flow when receiving cross-chain messages.\n *\n * Actual implementations of cross-chain aware contracts, which are based on\n * this abstraction, will  have to inherit from a bridge-specific\n * specialization. Such specializations are provided under\n * `crosschain/<chain>/CrossChainEnabled<chain>.sol`.\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabled {\n    /**\n     * @dev Throws if the current function call is not the result of a\n     * cross-chain execution.\n     */\n    modifier onlyCrossChain() {\n        if (!_isCrossChain()) revert NotCrossChainCall();\n        _;\n    }\n\n    /**\n     * @dev Throws if the current function call is not the result of a\n     * cross-chain execution initiated by `account`.\n     */\n    modifier onlyCrossChainSender(address expected) {\n        address actual = _crossChainSender();\n        if (expected != actual) revert InvalidCrossChainSender(actual, expected);\n        _;\n    }\n\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message.\n     */\n    function _isCrossChain() internal view virtual returns (bool);\n\n    /**\n     * @dev Returns the address of the sender of the cross-chain message that\n     * triggered the current function call.\n     *\n     * IMPORTANT: Should revert with `NotCrossChainCall` if the current function\n     * call is not the result of a cross-chain message.\n     */\n    function _crossChainSender() internal view virtual returns (address);\n\n    /**\n     * @dev Sends a generic cross-chain message through a bridge.\n     *\n     * IMPORTANT: The structure of the crossChainTxParams is defined in the implementations\n     * and can be built using the SDKs of the corresponding bridge most of the times.\n     *\n     * @param destination The address of the cross-chain target contract.\n     * @param data The calldata of the cross-chain call.\n     * @param crossChainTxParams An ABI encoded struct representing the configuration required\n     * for the message to be sent through the bridge.\n     */\n    function _sendCrossChainMessage(\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal virtual;\n}\n"
    },
    "contracts/crosschain/arbitrum/LibArbitrumL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/arbitrum/LibArbitrumL1.sol)\n\npragma solidity ^0.8.4;\n\nimport {IBridge as ArbitrumL1_Bridge} from \"../../vendor/arbitrum/IBridge.sol\";\nimport {IInbox as ArbitrumL1_Inbox} from \"../../vendor/arbitrum/IInbox.sol\";\nimport {IOutbox as ArbitrumL1_Outbox} from \"../../vendor/arbitrum/IOutbox.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for\n * https://arbitrum.io/[Arbitrum].\n *\n * This version should only be used on L1 to process cross-chain messages\n * originating from L2, or to send cross-chain messages from L1 to L2. For\n * the other side, use {LibArbitrumL2}.\n */\nlibrary LibArbitrumL1 {\n    /**\n     * @dev This is the keccak256('Arbitrum-L1L2')\n     */\n    bytes4 public constant BRIDGE_ID = 0xf99ba2be;\n\n    /**\n     * @dev These are the parameters required for creating the Retryable Ticket in L2.\n     *\n     * NOTE: Refer to the https://developer.offchainlabs.com/docs/l1_l2_messages#parameters[Parameters Docs] in Arbitrum\n     * for a detailed explanation of each param.\n     *\n     * @param bridgeId This Id is used to ensure this bridge only send messages intended for this bridge,\n     * avoiding some unexpected scenarios if a config for a different bridge matches.\n     */\n    struct CrossChainTxParams {\n        bytes4 bridgeId;\n        uint256 depositValue;\n        uint256 l2CallValue;\n        uint256 maxSubmissionCost;\n        address excessFeeRefundAddress;\n        address callValueRefundAddress;\n        uint256 maxGas;\n        uint256 gasPriceBid;\n    }\n\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by the `bridge`.\n     */\n    function isCrossChain(address bridge) internal view returns (bool) {\n        return msg.sender == bridge;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through the `bridge`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address bridge) internal view returns (address) {\n        if (!isCrossChain(bridge)) revert NotCrossChainCall();\n\n        address sender = ArbitrumL1_Outbox(ArbitrumL1_Bridge(bridge).activeOutbox()).l2ToL1Sender();\n        require(sender != address(0), \"LibArbitrumL1: system messages without sender\");\n\n        return sender;\n    }\n\n    /**\n     * @dev Sends a cross-chain message from L1 to L2 via `Inbox`.\n     * @param bridge The Bridge contract in the L1.\n     * @param destination The address of the cross-chain target contract.\n     * @param data The calldata of the cross-chain call.\n     * @param crossChainTxParams An ABI encoded {CrossChainTxParams} representing the parameters required\n     * for the message to be sent through the bridge.\n     * @return ticketId A unique identifier for the Retryable Ticket created.\n     */\n    function sendCrossChainMessage(\n        address bridge,\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal returns (uint256 ticketId) {\n        address delayedInbox = ArbitrumL1_Bridge(bridge).allowedInboxList(0);\n\n        CrossChainTxParams memory params = abi.decode(crossChainTxParams, (CrossChainTxParams));\n\n        if (BRIDGE_ID != params.bridgeId) revert InvalidTargetBridge(params.bridgeId, BRIDGE_ID);\n\n        ticketId = ArbitrumL1_Inbox(delayedInbox).createRetryableTicket{value: params.depositValue}(\n            destination,\n            params.l2CallValue,\n            params.maxSubmissionCost,\n            params.excessFeeRefundAddress,\n            params.callValueRefundAddress,\n            params.maxGas,\n            params.gasPriceBid,\n            data\n        );\n    }\n}\n"
    },
    "contracts/crosschain/errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\nerror InvalidTargetBridge(bytes32 actual, bytes32 expected);\n"
    },
    "contracts/vendor/arbitrum/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IBridge.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    event BridgeCallTriggered(address indexed outbox, address indexed destAddr, uint256 amount, bytes data);\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxList(uint256 index) external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"
    },
    "contracts/vendor/arbitrum/IInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IInbox.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicketNoRefundAliasRewrite(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (address);\n\n    function pauseCreateRetryables() external;\n\n    function unpauseCreateRetryables() external;\n\n    function startRewriteAddress() external;\n\n    function stopRewriteAddress() external;\n}\n"
    },
    "contracts/vendor/arbitrum/IOutbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IOutbox.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\ninterface IOutbox {\n    event OutboxEntryCreated(\n        uint256 indexed batchNum,\n        uint256 outboxEntryIndex,\n        bytes32 outputRoot,\n        uint256 numInBatch\n    );\n    event OutBoxTransactionExecuted(\n        address indexed destAddr,\n        address indexed l2Sender,\n        uint256 indexed outboxEntryIndex,\n        uint256 transactionIndex\n    );\n\n    function l2ToL1Sender() external view returns (address);\n\n    function l2ToL1Block() external view returns (uint256);\n\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    function l2ToL1BatchNum() external view returns (uint256);\n\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths) external;\n\n    function outboxEntryExists(uint256 batchNum) external view returns (bool);\n}\n"
    },
    "contracts/vendor/arbitrum/IMessageProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IMessageProvider.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\ninterface IMessageProvider {\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "contracts/senders/SenderOptimismL1.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"../crosschain/optimism/CrossChainEnabledOptimismL1.sol\";\n\ncontract SenderOptimismL1 is CrossChainEnabledOptimismL1 {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address bridge_) CrossChainEnabledOptimismL1(bridge_) {}\n\n    function sendCrossChainMessage(\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) external payable {\n        _sendCrossChainMessage(destination, data, crossChainTxParams);\n    }\n}\n"
    },
    "contracts/crosschain/optimism/CrossChainEnabledOptimismL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/optimism/CrossChainEnabledOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"./LibOptimismL1.sol\";\n\n/**\n * @dev https://www.optimism.io/[Optimism] specialization or the\n * {CrossChainEnabled} abstraction.\n *\n * The bridge (`L1StandardBridge`) contract is provided and maintained by\n * the optimism team. You can find the address of this contract on mainnet and\n * kovan in the https://github.com/ethereum-optimism/optimism/tree/develop/packages/contracts/deployments[deployments section of Optimism monorepo].\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabledOptimismL1 is CrossChainEnabled {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _l1StandardBridge;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address l1StandardBridge) {\n        _l1StandardBridge = l1StandardBridge;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        return LibOptimismL1.isCrossChain(_l1StandardBridge);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        return LibOptimismL1.crossChainSender(_l1StandardBridge);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_sendCrossChainMessage}\n     */\n    function _sendCrossChainMessage(\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal virtual override {\n        LibOptimismL1.sendCrossChainMessage(_l1StandardBridge, destination, data, crossChainTxParams);\n    }\n}\n"
    },
    "contracts/crosschain/optimism/LibOptimismL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/optimism/LibOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport {ICrossDomainMessenger} from \"../../vendor/optimism/ICrossDomainMessenger.sol\";\nimport {IL1StandardBridge} from \"../../vendor/optimism/IL1StandardBridge.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for https://www.optimism.io/[Optimism].\n * See the https://community.optimism.io/docs/developers/bridge/messaging/#accessing-msg-sender[documentation]\n * for the functionality used here.\n *\n * This version should only be used on L1 to process cross-chain messages\n * originating from L2, or to send cross-chain messages from L1 to L2. For\n * the other side, use {LibOptimismL2}.\n */\nlibrary LibOptimismL1 {\n    /**\n     * @dev This is the keccak256('Optimism-L1L2')\n     */\n    bytes4 public constant BRIDGE_ID = 0x8a69005a;\n\n    /**\n     * @dev These are the parameters required for sending the cross-chain message.\n     *\n     * @param bridgeId This Id is used to ensure this bridge only send messages intended for this bridge,\n     * avoiding some unexpected scenarios if a config for a different bridge matches.\n     */\n    struct CrossChainTxParams {\n        bytes4 bridgeId;\n        uint32 gasLimit;\n        uint256 depositValue;\n    }\n\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `messenger`.\n     */\n    function isCrossChain(address bridge) internal view returns (bool) {\n        address messenger = IL1StandardBridge(bridge).messenger();\n\n        return msg.sender == messenger;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `messenger`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address bridge) internal view returns (address) {\n        address messenger = IL1StandardBridge(bridge).messenger();\n\n        if (!isCrossChain(messenger)) revert NotCrossChainCall();\n\n        return ICrossDomainMessenger(messenger).xDomainMessageSender();\n    }\n\n    /**\n     * @dev Sends a cross-chain message via `messenger`.\n     *\n     * NOTE: Check https://community.optimism.io/docs/developers/bridge/messaging/#[Fees for sending data between L1 and L2]\n     * to understand gasLimit implications.\n     *\n     * @param bridge The L1StandardBridge contract representing the bridge.\n     * @param destination The address of the cross-chain target contract.\n     * @param data The calldata of the cross-chain call.\n     * @param crossChainTxParams An ABI encoded {CrossChainTxParams} representing the parameters required\n     * for the message to be sent through the bridge.\n     */\n    function sendCrossChainMessage(\n        address bridge,\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal {\n        CrossChainTxParams memory params = abi.decode(crossChainTxParams, (CrossChainTxParams));\n\n        if (BRIDGE_ID != params.bridgeId) revert InvalidTargetBridge(params.bridgeId, BRIDGE_ID);\n\n        if (params.depositValue > 0) {\n            // deposit ETH through standard bridge\n            IL1StandardBridge(bridge).depositETHTo{value: params.depositValue}(\n                destination,\n                params.gasLimit,\n                data\n            );\n        } else {\n            // send the message directly through the messenger\n            address messenger = IL1StandardBridge(bridge).messenger();\n            ICrossDomainMessenger(messenger).sendMessage(destination, data, params.gasLimit);\n        }\n    }\n}\n"
    },
    "contracts/vendor/optimism/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/optimism/ICrossDomainMessenger.sol)\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param target Target contract address.\n     * @param message Message to send to the target.\n     * @param gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address target,\n        bytes calldata message,\n        uint32 gasLimit\n    ) external;\n}\n"
    },
    "contracts/vendor/optimism/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge {\n    /********************\n     * Public Functions *\n     ********************/\n\n    function messenger() external view returns (address);\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}