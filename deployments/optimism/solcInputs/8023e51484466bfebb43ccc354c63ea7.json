{
  "language": "Solidity",
  "sources": {
    "contracts/GreeterOnlyCrossChain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./crosschain/optimism/CrossChainEnabledOptimismL1.sol\";\n\ncontract GreeterOnlyCrossChain is CrossChainEnabledOptimismL1 {\n    string private _greeting;\n\n    constructor(address bridge_, string memory greeting_) CrossChainEnabledOptimismL1(bridge_) {\n        _greeting = greeting_;\n    }\n\n    function greet() public view returns (string memory) {\n        return _greeting;\n    }\n\n    function setGreeting(string memory greeting_) public payable onlyCrossChain {\n        _greeting = greeting_;\n    }\n}\n"
    },
    "contracts/crosschain/optimism/CrossChainEnabledOptimismL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/optimism/CrossChainEnabledOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"./LibOptimismL1.sol\";\n\n/**\n * @dev https://www.optimism.io/[Optimism] specialization or the\n * {CrossChainEnabled} abstraction.\n *\n * The bridge (`L1StandardBridge`) contract is provided and maintained by\n * the optimism team. You can find the address of this contract on mainnet and\n * kovan in the https://github.com/ethereum-optimism/optimism/tree/develop/packages/contracts/deployments[deployments section of Optimism monorepo].\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabledOptimismL1 is CrossChainEnabled {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _l1StandardBridge;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address l1StandardBridge) {\n        _l1StandardBridge = l1StandardBridge;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        address messenger = IL1StandardBridge(_l1StandardBridge).messenger();\n\n        return LibOptimismL1.isCrossChain(messenger);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        address messenger = IL1StandardBridge(_l1StandardBridge).messenger();\n\n        return LibOptimismL1.crossChainSender(messenger);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_sendCrossChainMessage}\n     */\n    function _sendCrossChainMessage(\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal virtual override {\n        LibOptimismL1.sendCrossChainMessage(_l1StandardBridge, destination, data, crossChainTxParams);\n    }\n}\n"
    },
    "contracts/crosschain/CrossChainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/CrossChainEnabled.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./errors.sol\";\n\n/**\n * @dev Provides information for building cross-chain aware contracts. This\n * abstract contract provides accessors and modifiers to control the execution\n * flow when receiving cross-chain messages.\n *\n * Actual implementations of cross-chain aware contracts, which are based on\n * this abstraction, will  have to inherit from a bridge-specific\n * specialization. Such specializations are provided under\n * `crosschain/<chain>/CrossChainEnabled<chain>.sol`.\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabled {\n    /**\n     * @dev Throws if the current function call is not the result of a\n     * cross-chain execution.\n     */\n    modifier onlyCrossChain() {\n        if (!_isCrossChain()) revert NotCrossChainCall();\n        _;\n    }\n\n    /**\n     * @dev Throws if the current function call is not the result of a\n     * cross-chain execution initiated by `account`.\n     */\n    modifier onlyCrossChainSender(address expected) {\n        address actual = _crossChainSender();\n        if (expected != actual) revert InvalidCrossChainSender(actual, expected);\n        _;\n    }\n\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message.\n     */\n    function _isCrossChain() internal view virtual returns (bool);\n\n    /**\n     * @dev Returns the address of the sender of the cross-chain message that\n     * triggered the current function call.\n     *\n     * IMPORTANT: Should revert with `NotCrossChainCall` if the current function\n     * call is not the result of a cross-chain message.\n     */\n    function _crossChainSender() internal view virtual returns (address);\n\n    /**\n     * @dev Sends a generic cross-chain message through a bridge.\n     *\n     * IMPORTANT: The structure of the crossChainTxParams is defined in the implementations\n     * and can be built using the SDKs of the corresponding bridge most of the times.\n     *\n     * @param destination The address of the cross-chain target contract.\n     * @param data The calldata of the cross-chain call.\n     * @param crossChainTxParams An ABI encoded struct representing the configuration required\n     * for the message to be sent through the bridge.\n     */\n    function _sendCrossChainMessage(\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal virtual;\n}\n"
    },
    "contracts/crosschain/optimism/LibOptimismL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/optimism/LibOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport {ICrossDomainMessenger} from \"../../vendor/optimism/ICrossDomainMessenger.sol\";\nimport {IL1StandardBridge} from \"../../vendor/optimism/IL1StandardBridge.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for https://www.optimism.io/[Optimism].\n * See the https://community.optimism.io/docs/developers/bridge/messaging/#accessing-msg-sender[documentation]\n * for the functionality used here.\n *\n * This version should only be used on L1 to process cross-chain messages\n * originating from L2, or to send cross-chain messages from L1 to L2. For\n * the other side, use {LibOptimismL2}.\n */\nlibrary LibOptimismL1 {\n    /**\n     * @dev This is the keccak256('Optimism-L1L2')\n     */\n    bytes4 public constant BRIDGE_ID = 0x8a69005a;\n\n    /**\n     * @dev These are the parameters required for sending the cross-chain message.\n     *\n     * @param bridgeId This Id is used to ensure this bridge only send messages intended for this bridge,\n     * avoiding some unexpected scenarios if a config for a different bridge matches.\n     */\n    struct CrossChainTxParams {\n        bytes4 bridgeId;\n        uint32 gasLimit;\n        uint256 depositValue;\n    }\n\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `messenger`.\n     */\n    function isCrossChain(address messenger) internal view returns (bool) {\n        return msg.sender == messenger;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `messenger`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address messenger) internal view returns (address) {\n        if (!isCrossChain(messenger)) revert NotCrossChainCall();\n\n        return ICrossDomainMessenger(messenger).xDomainMessageSender();\n    }\n\n    /**\n     * @dev Sends a cross-chain message via `messenger`.\n     *\n     * NOTE: Check https://community.optimism.io/docs/developers/bridge/messaging/#[Fees for sending data between L1 and L2]\n     * to understand gasLimit implications.\n     *\n     * @param bridge The L1StandardBridge contract representing the bridge.\n     * @param destination The address of the cross-chain target contract.\n     * @param data The calldata of the cross-chain call.\n     * @param crossChainTxParams An ABI encoded {CrossChainTxParams} representing the parameters required\n     * for the message to be sent through the bridge.\n     */\n    function sendCrossChainMessage(\n        address bridge,\n        address destination,\n        bytes memory data,\n        bytes memory crossChainTxParams\n    ) internal {\n        CrossChainTxParams memory params = abi.decode(crossChainTxParams, (CrossChainTxParams));\n\n        if (BRIDGE_ID != params.bridgeId) revert InvalidTargetBridge(params.bridgeId, BRIDGE_ID);\n\n        if (params.depositValue > 0) {\n            // deposit ETH through standard bridge\n            IL1StandardBridge(bridge).depositETHTo{value: params.depositValue}(destination, params.gasLimit, data);\n        } else {\n            // send the message directly through the messenger\n            address messenger = IL1StandardBridge(bridge).messenger();\n            ICrossDomainMessenger(messenger).sendMessage(destination, data, params.gasLimit);\n        }\n    }\n}\n"
    },
    "contracts/crosschain/errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\nerror InvalidTargetBridge(bytes4 actual, bytes4 expected);\n"
    },
    "contracts/vendor/optimism/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/optimism/ICrossDomainMessenger.sol)\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param target Target contract address.\n     * @param message Message to send to the target.\n     * @param gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address target,\n        bytes calldata message,\n        uint32 gasLimit\n    ) external;\n}\n"
    },
    "contracts/vendor/optimism/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge {\n    /********************\n     * Public Functions *\n     ********************/\n\n    function messenger() external view returns (address);\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}